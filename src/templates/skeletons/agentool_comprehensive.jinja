"""
{{ tool_name }} AgenTool - [Brief description of what this tool does].

This AgenTool provides [detailed explanation of functionality and purpose].
It integrates with [list of dependencies] to [explain integration approach].

Key Features:
- [Feature 1]: [Brief description]
- [Feature 2]: [Brief description]
- [Feature 3]: [Brief description]

Usage Example:
    >>> from agentoolkit.{{ tool_name }} import create_{{ tool_name }}_agent
    >>> from agentool.core.injector import get_injector
    >>> 
    >>> # Create and register the agent
    >>> agent = create_{{ tool_name }}_agent()
    >>> 
    >>> # Use through injector
    >>> injector = get_injector()
    >>> result = await injector.run('{{ tool_name }}', {
    ...     "operation": "example_operation",
    ...     "param": "value"
    ... })
"""

import json
from typing import Dict, Any, List, Optional, Literal
from pydantic import BaseModel, Field, field_validator  # DO NOT REMOVE
from pydantic_ai import RunContext  # DO NOT REMOVE

from agentool import create_agentool  # DO NOT REMOVE
from agentool.base import BaseOperationInput  # DO NOT REMOVE
from agentool.core.registry import RoutingConfig  # DO NOT REMOVE
from agentool.core.injector import get_injector  # DO NOT REMOVE


class {{ tool_name|capitalize }}Input(BaseOperationInput):
    """Input schema for {{ tool_name }} operations.
    
    IMPORTANT: Every field here must map to function parameters via routing.
    Field names should be descriptive and match their usage in functions.
    """
    operation: Literal['operation1', 'operation2', 'operation3'] = Field(
        description="The operation to perform"
    )
    
    # Fields for operation1 (match function parameters exactly)
    param1: Optional[str] = Field(
        None,
        description="Required for operation1: describe what param1 does"
    )
    param2: Optional[Any] = Field(
        None,
        description="Optional for operation1: describe what param2 does"
    )
    
    # Fields for operation2
    key: Optional[str] = Field(
        None,
        description="Required for operation2: unique identifier key"
    )
    value: Optional[Any] = Field(
        None,
        description="Required for operation2: value to process"
    )
    ttl: Optional[int] = Field(
        None,
        description="Optional for operation2: time-to-live in seconds"
    )
    
    # Fields for operation3
    items: Optional[List[str]] = Field(
        None,
        description="Required for operation3: list of items to process"
    )
    batch_size: Optional[int] = Field(
        10,
        description="Optional for operation3: processing batch size"
    )
    
    @field_validator('param1')
    @classmethod
    def validate_param1(cls, v, info):
        """Validate param1 is provided for operation1."""
        operation = info.data.get('operation')
        if operation == 'operation1' and not v:
            raise ValueError("param1 is required for operation1")
        return v
    
    @field_validator('key', 'value')
    @classmethod
    def validate_operation2_fields(cls, v, info):
        """Validate required fields for operation2."""
        operation = info.data.get('operation')
        field_name = info.field_name
        if operation == 'operation2' and v is None:
            raise ValueError(f"{field_name} is required for operation2")
        return v
    
    @field_validator('items')
    @classmethod
    def validate_items(cls, v, info):
        """Validate items for operation3."""
        operation = info.data.get('operation')
        if operation == 'operation3' and not v:
            raise ValueError("items list is required for operation3")
        return v


class {{ tool_name|capitalize }}Output(BaseModel):
    """Output schema for {{ tool_name }} operations."""
    operation: str = Field(description="The operation that was performed")
    success: bool = Field(description="Whether the operation succeeded")
    message: str = Field(description="Human-readable result message")
    data: Optional[Dict[str, Any]] = Field(None, description="Operation-specific data")


# Global state management (if needed)
# _state: Dict[str, Any] = {}


async def {{ tool_name }}_operation1(
    ctx: RunContext[Any],
    param1: str,
    param2: Optional[Any] = None
) -> {{ tool_name|capitalize }}Output:
    """
    Perform operation1.
    
    This function [detailed explanation of what operation1 does].
    
    IMPORTANT: All parameters must be explicitly defined in the function signature.
    Never use **kwargs as Pydantic needs to discover the exact parameters.
    
    Args:
        ctx: Runtime context provided by the framework
        param1: Description of what param1 does (required parameter)
        param2: Description of what param2 does (optional parameter with default)
        
    Returns:
        {{ tool_name|capitalize }}Output with operation results containing:
        - success: Whether the operation succeeded
        - message: Human-readable result message
        - data: Operation-specific return data
        
    Raises:
        ValueError: If param1 is invalid or doesn't meet requirements
        RuntimeError: If operation fails due to system issues
    """
    injector = get_injector()
    
    try:
        # Implementation logic here
        
        # Example: Use other agentools
        # result = await injector.run('storage_kv', {
        #     'operation': 'get',
        #     'key': 'some_key',
        #     'namespace': 'my_namespace'
        # })
        # assert result.success is True
        # value = result.data.get('value')
        
        # Log the operation
        await injector.run('logging', {
            'operation': 'log',
            'level': 'INFO', # DEBUG, INFO, WARN, ERROR, CRITICAL
            'logger_name': '{{ tool_name }}',
            'message': 'Operation1 executed successfully',
            'data': {'param': 'value'}
        })
        
        # Track business metrics
        await injector.run('metrics', {
            'operation': 'increment',
            'name': 'agentool.{{ tool_name }}.my_business_metric.count',
            'labels': {'cardinality': 'value'}
        })
        
        return {{ tool_name|capitalize }}Output(
            operation="operation1",
            success=True,
            message="Operation1 completed successfully",
            data={"result": "value"}
        )
        
    except Exception as e:
        # Log error
        await injector.run('logging', {
            'operation': 'log',
            'level': 'ERROR',
            'logger_name': '{{ tool_name }}',
            'message': 'Operation1 failed',
            'data': {'error': str(e)}
        })
        
        # Track business error metric
        await injector.run('metrics', {
            'operation': 'increment',
            'name': 'agentool.{{ tool_name }}.my_business_metric.errors'
        })
        
        raise


async def {{ tool_name }}_operation2(
    ctx: RunContext[Any],
    key: str,
    value: Any,
    ttl: Optional[int] = None
) -> {{ tool_name|capitalize }}Output:
    """
    Perform operation2.
    
    Example of a function with multiple parameters. All must be explicit.
    
    Args:
        ctx: Runtime context provided by the framework
        key: The key identifier for this operation
        value: The value to process
        ttl: Optional time-to-live in seconds (defaults to None for no expiry)
        
    Returns:
        {{ tool_name|capitalize }}Output with operation results
    """
    # Implementation for operation2
    return {{ tool_name|capitalize }}Output(
        operation="operation2",
        success=True,
        message="Operation2 completed",
        data={"key": key, "processed": True}
    )


async def {{ tool_name }}_operation3(
    ctx: RunContext[Any],
    items: List[str],
    batch_size: int = 10
) -> {{ tool_name|capitalize }}Output:
    """
    Perform operation3 - example of batch processing.
    
    Shows how to handle list parameters with explicit typing.
    
    Args:
        ctx: Runtime context provided by the framework
        items: List of items to process in this operation
        batch_size: Number of items to process at once (default: 10)
        
    Returns:
        {{ tool_name|capitalize }}Output with operation results
        
    Note:
        Always define explicit parameters. The routing lambda will map
        from the input schema fields to these exact parameter names.
    """
    # Implementation for operation3
    return {{ tool_name|capitalize }}Output(
        operation="operation3",
        success=True,
        message=f"Processed {len(items)} items in batches of {batch_size}",
        data={"processed_count": len(items)}
    )


# Routing configuration - CRITICAL: Map input schema fields to exact function parameters
{{ tool_name }}_routing = RoutingConfig(
    operation_field='operation',
    operation_map={
        'operation1': ('{{ tool_name }}_operation1', lambda x: {
            # Map EXACTLY to function parameter names (no **kwargs!)
            'param1': x.param1,  # Required field from input schema
            'param2': x.param2,  # Optional field from input schema
        }),
        'operation2': ('{{ tool_name }}_operation2', lambda x: {
            # These names MUST match the function parameters exactly
            'key': x.key,
            'value': x.value,
            'ttl': x.ttl,  # Can be None if not provided
        }),
        'operation3': ('{{ tool_name }}_operation3', lambda x: {
            # Map list fields and optional parameters
            'items': x.items,
            'batch_size': x.batch_size if hasattr(x, 'batch_size') else 10,
        }),
    }
)


def create_{{ tool_name }}_agent():
    """
    Create and return the {{ tool_name }} AgenTool.
    
    Returns:
        Agent configured for {{ tool_name }} operations
    """
    return create_agentool(
        name='{{ tool_name }}',
        input_schema={{ tool_name|capitalize }}Input,
        routing_config={{ tool_name }}_routing,
        tools=[{{ tool_name }}_operation1, {{ tool_name }}_operation2, {{ tool_name }}_operation3],
        output_type={{ tool_name|capitalize }}Output,
        system_prompt="[System prompt describing the agent's role and capabilities]",
        description="[One-line description of what this agent does including a list of operations]",
        version="1.0.0",
        tags=["tag1", "tag2", "tag3"],
        dependencies=["storage_kv", "logging", "metrics"],  # List actual agentool dependencies
        examples=[
            {
                "description": "Example of operation1",
                "input": {
                    "operation": "operation1",
                    # Add example input fields
                },
                "output": {
                    "operation": "operation1",
                    "success": True,
                    "message": "Operation1 completed successfully",
                    "data": {"result": "value"}
                }
            },
            # Add one valid example for other operations
        ]
    )


# Create the agent instance
agent = create_{{ tool_name }}_agent()